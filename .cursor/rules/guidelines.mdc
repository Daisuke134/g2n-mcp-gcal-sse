---
description: 
globs: 
alwaysApply: true
---
# G2NTech - Project Rules

## 1. Nomenclatura de Diret√≥rios
- Use **nomes descritivos** e **em ingl√™s**.
- Utilize `kebab-case` para **nomes de diret√≥rios** (ex.: `user-authentication`).
- Para **arquivos TypeScript**, siga estas conven√ß√µes:
  - `camelCase.ts` ‚Üí Para arquivos utilit√°rios, fun√ß√µes ou hooks (ex.: `fetchData.ts`).
  - `PascalCase.tsx` ‚Üí Para **componentes React** (ex.: `UserProfile.tsx`).
- Separe diret√≥rios por **contexto**, como:
  - **`src/`** ‚Üí C√≥digo-fonte principal.
  - **`docs/`** ‚Üí Documenta√ß√£o.
  - **`tests/`** ‚Üí Testes unit√°rios e de integra√ß√£o.
  - **`/`** ‚Üí Configura√ß√µes (ex.: `eslint`, `prettier`, `tsconfig.json`).
  - **`types/`** ‚Üí Defini√ß√µes de tipos globais (`types/global.d.ts`).
  - **`public/`** ‚Üí Recursos est√°ticos (se aplic√°vel).

## 2. README do Projeto
Cada reposit√≥rio deve conter um `README.md` detalhado com:
- **Descri√ß√£o:** Objetivo e funcionalidades do projeto.
- **Instala√ß√£o:** Passo a passo para configurar o ambiente.
- **Uso:** Exemplos de uso e comandos principais.
- **Configura√ß√£o:** Op√ß√µes de configura√ß√£o dispon√≠veis.
- **Contribui√ß√£o:** Diretrizes para novos contribuidores.
- **Licen√ßa:** Tipo de licen√ßa utilizada.
- **Propriedade:** Deve ficar claro que o projeto pertence √† G2NTech e foi desenvolvido por **Gabriel Augusto** (@oaugustosgabriel).

### 2.1. Estrutura Bil√≠ngue do README
Para alcan√ßar um p√∫blico global sem deixar de atender o p√∫blico brasileiro, siga esta estrutura:
1. **README principal (`README.md`) deve estar em ingl√™s** (padr√£o global no GitHub).
2. **Vers√£o em portugu√™s (`README.pt-br.md`)** com um link no topo do README principal.

**Exemplo de cabe√ßalho no README principal:**
```md
# Project Name

üåé This README is available in multiple languages:
- üá∫üá∏ [English](mdc:README.md)
- üáßüá∑ [Portugu√™s](mdc:README.pt-br.md)
```
Dessa forma, os usu√°rios internacionais encontram o projeto com mais facilidade, enquanto os brasileiros ainda t√™m acesso ao conte√∫do no idioma nativo.

## 3. Diretrizes de Contribui√ß√£o
- Utilize branches seguindo o padr√£o: `feature/nome-da-feature` ou `fix/nome-do-bug`.
- Submeta PRs (Pull Requests) com descri√ß√£o clara das mudan√ßas.
- Mantenha o c√≥digo consistente com o estilo do projeto.
- Inclua testes unit√°rios sempre que poss√≠vel.
- Adicione documenta√ß√£o para novas funcionalidades.

## 4. Licen√ßa
Todos os projetos ser√£o open source sob a **Licen√ßa MIT**. Um arquivo `LICENSE` deve estar presente na raiz do reposit√≥rio.

## 5. Commits e Releases
### Commits
- Siga a conven√ß√£o de commits sem√¢nticos:
  ```
  <tipo>: <descri√ß√£o breve>
  ```
  **Tipos comuns:**
  - `feat`: nova funcionalidade
  - `fix`: corre√ß√£o de bug
  - `docs`: mudan√ßas na documenta√ß√£o
  - `style`: ajustes de formata√ß√£o
  - `refactor`: refatora√ß√£o sem alterar funcionalidade
  - `test`: adi√ß√£o/modifica√ß√£o de testes
  - `chore`: manuten√ß√£o do projeto
- Mensagens de commit devem ser claras e objetivas (m√°x. 72 caracteres no t√≠tulo).
- Exemplo de commit bem estruturado:
  ```
  feat: adiciona autentica√ß√£o via OAuth
  
  Implementa suporte para autentica√ß√£o de usu√°rios utilizando OAuth 2.0.
  Inclui integra√ß√£o com Google e GitHub.
  ```

### Releases
- Utilize versionamento sem√¢ntico (`MAJOR.MINOR.PATCH`).
- Criar releases no GitHub com changelogs documentando mudan√ßas.
- Tags devem seguir o padr√£o: `vX.Y.Z` (ex.: `v1.2.0`).

## 6. Boas Pr√°ticas para TypeScript
### Configura√ß√£o do TypeScript
A configura√ß√£o do TypeScript deve seguir o seguinte `tsconfig.json`:
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "outDir": "./build",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```

### Estilo de C√≥digo
- Utilize `camelCase` para vari√°veis e fun√ß√µes.
- Utilize `PascalCase` para nomes de classes e tipos.
- Evite `any`, prefira `unknown` ou `never` sempre que poss√≠vel.
- Sempre declare o tipo de retorno das fun√ß√µes.
- Utilize `readonly` para propriedades que n√£o devem ser modificadas.
- Prefira `const` sobre `let` sempre que poss√≠vel.

### Uso do Zod
√â obrigat√≥rio o uso da biblioteca [Zod](mdc:https:/zod.dev) para valida√ß√£o de dados. Exemplo de uso:
```ts
import { z } from "zod";

const UserSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(2),
  email: z.string().email()
});

type User = z.infer<typeof UserSchema>;
```

### Scripts de Build
O script de build deve garantir permiss√µes de execu√ß√£o para o arquivo de entrada:
```json
"scripts": {
  "build": "tsc && chmod 755 build/{entrypoint}.js"
}
```
Substitua `{entrypoint}` pelo nome do arquivo de entrada do projeto.

### Boas Pr√°ticas Gerais
- Separe c√≥digo de infraestrutura (configura√ß√£o, banco, etc.) do c√≥digo de regras de neg√≥cio.
- Use `async/await` para opera√ß√µes ass√≠ncronas.
- Evite muta√ß√µes de estado desnecess√°rias.
- Utilize interfaces e tipos para garantir seguran√ßa est√°tica.
- Prefira `Record<K, V>` para objetos indexados ao inv√©s de `{ [key: string]: Type }`.
- Mantenha arquivos pequenos e organizados por responsabilidade.

## 7. Redes Sociais e Contato
Para mais conte√∫dos, tutoriais e intera√ß√£o, siga **Gabriel Augusto (@oaugustosgabriel)**:
- üì∫ **YouTube:** [youtube.com/@oaugustosgabriel](mdc:https:/www.youtube.com/@oaugustosgabriel) ‚Äì Assista aos v√≠deos e interaja nos coment√°rios!
- üì∏ **Instagram:** [instagram.com/oaugustosgabriel](mdc:https:/www.instagram.com/oaugustosgabriel) ‚Äì Mande um direct e acompanhe novidades!
- üìß **Contato por e-mail:** [gabriel@g2ngroup.com.br](mdc:mailto:gabriel@g2ngroup.com.br)

## 8. Apoie o Projeto üíú
Se este projeto for √∫til para voc√™ e quiser contribuir, aceitamos doa√ß√µes via **PIX**:
- **Chave PIX:** `gabriel@g2ngroup.com`
- ![QR Code para doa√ß√£o](mdc:INSERIR_LINK_DO_QR_CODE_AQUI)

Toda contribui√ß√£o ajuda a manter e evoluir os projetos open-source! üöÄ

# Core architecture

Understand how MCP connects clients, servers, and LLMs

The Model Context Protocol (MCP) is built on a flexible, extensible architecture that enables seamless communication between LLM applications and integrations. This document covers the core architectural components and concepts.

## Overview

MCP follows a client-server architecture where:

*   **Hosts** are LLM applications (like Claude Desktop or IDEs) that initiate connections
*   **Clients** maintain 1:1 connections with servers, inside the host application
*   **Servers** provide context, tools, and prompts to clients

```mermaid
flowchart LR
    subgraph "&nbsp;Host (e.g., Claude Desktop)&nbsp;"
        client1[MCP Client]
        client2[MCP Client]
    end
    subgraph "Server Process"
        server1[MCP Server]
    end
    subgraph "Server Process"
        server2[MCP Server]
    end

    client1 <-->|Transport Layer| server1
    client2 <-->|Transport Layer| server2
```

## Core components

### Protocol layer

The protocol layer handles message framing, request/response linking, and high-level communication patterns.

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    class Protocol<Request, Notification, Result> {
        // Handle incoming requests
        setRequestHandler<T>(schema: T, handler: (request: T, extra: RequestHandlerExtra) => Promise<Result>): void

        // Handle incoming notifications
        setNotificationHandler<T>(schema: T, handler: (notification: T) => Promise<void>): void

        // Send requests and await responses
        request<T>(request: Request, schema: T, options?: RequestOptions): Promise<T>

        // Send one-way notifications
        notification(notification: Notification): Promise<void>
    }
    ```
  </Tab>
</Tabs>

Key classes include:

*   `Protocol`
*   `Client`
*   `Server`

### Transport layer

The transport layer handles the actual communication between clients and servers. MCP supports multiple transport mechanisms:

1.  **Stdio transport**
    *   Uses standard input/output for communication
    *   Ideal for local processes

2.  **HTTP with SSE transport**
    *   Uses Server-Sent Events for server-to-client messages
    *   HTTP POST for client-to-server messages

All transports use [JSON-RPC](mdc:https:/www.jsonrpc.org) 2.0 to exchange messages. See the [specification](mdc:https:/spec.modelcontextprotocol.io) for detailed information about the Model Context Protocol message format.

### Message types

MCP has these main types of messages:

1.  **Requests** expect a response from the other side:
    ```typescript
    interface Request {
      method: string;
      params?: { ... };
    }
    ```

2.  **Notifications** are one-way messages that don't expect a response:
    ```typescript
    interface Notification {
      method: string;
      params?: { ... };
    }
    ```

3.  **Results** are successful responses to requests:
    ```typescript
    interface Result {
      [key: string]: unknown;
    }
    ```

4.  **Errors** indicate that a request failed:
    ```typescript
    interface Error {
      code: number;
      message: string;
      data?: unknown;
    }
    ```

## Connection lifecycle

### 1. Initialization

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Client->>Server: initialize request
    Server->>Client: initialize response
    Client->>Server: initialized notification

    Note over Client,Server: Connection ready for use
```

1.  Client sends `initialize` request with protocol version and capabilities
2.  Server responds with its protocol version and capabilities
3.  Client sends `initialized` notification as acknowledgment
4.  Normal message exchange begins

### 2. Message exchange

After initialization, the following patterns are supported:

*   **Request-Response**: Client or server sends requests, the other responds
*   **Notifications**: Either party sends one-way messages

### 3. Termination

Either party can terminate the connection:

*   Clean shutdown via `close()`
*   Transport disconnection
*   Error conditions

## Error handling

MCP defines these standard error codes:

```typescript
enum ErrorCode {
  // Standard JSON-RPC error codes
  ParseError = -32700,
  InvalidRequest = -32600,
  MethodNotFound = -32601,
  InvalidParams = -32602,
  InternalError = -32603
}
```

SDKs and applications can define their own error codes above -32000.

Errors are propagated through:

*   Error responses to requests
*   Error events on transports
*   Protocol-level error handlers

# MCP TypeScript SDK Guide

## Build & Test Commands
```
npm run build        # Build ESM and CJS versions
npm run lint         # Run ESLint
npm test             # Run all tests
npx jest path/to/file.test.ts  # Run specific test file
npx jest -t "test name"        # Run tests matching pattern
```

## Code Style Guidelines
- **TypeScript**: Strict type checking, ES modules, explicit return types
- **Naming**: PascalCase for classes/types, camelCase for functions/variables
- **Files**: Lowercase with hyphens, test files with `.test.ts` suffix
- **Imports**: ES module style, include `.js` extension, group imports logically
- **Error Handling**: Use TypeScript's strict mode, explicit error checking in tests
- **Formatting**: 2-space indentation, semicolons required, single quotes preferred
- **Testing**: Co-locate tests with source files, use descriptive test names
- **Comments**: JSDoc for public APIs, inline comments for complex logic

## Project Structure
- `/src`: Source code with client, server, and shared modules
- Tests alongside source files with `.test.ts` suffix
- Node.js >= 18 required

## Running Your Server

MCP servers in TypeScript need to be connected to a transport to communicate with clients.

### HTTP with SSE

For remote servers, start a web server with a Server-Sent Events (SSE) endpoint, and a separate endpoint for the client to send its messages to:

```typescript
import express, { Request, Response } from "express";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";

const server = new McpServer({
  name: "example-server",
  version: "1.0.0"
});

// ... set up server resources, tools, and prompts ...

const app = express();

// to support multiple simultaneous connections we have a lookup object from
// sessionId to transport
const transports: {[sessionId: string]: SSEServerTransport} = {};

app.get("/sse", async (_: Request, res: Response) => {
  const transport = new SSEServerTransport('/messages', res);
  transports[transport.sessionId] = transport;
  res.on("close", () => {
    delete transports[transport.sessionId];
  });
  await server.connect(transport);
});

app.post("/messages", async (req: Request, res: Response) => {
  const sessionId = req.query.sessionId as string;
  const transport = transports[sessionId];
  if (transport) {
    await transport.handlePostMessage(req, res);
  } else {
    res.status(400).send('No transport found for sessionId');
  }
});

app.listen(3001);
```

## Best practices

### Transport selection

1.  **Local communication**
    *   Use stdio transport for local processes
    *   Efficient for same-machine communication
    *   Simple process management

2.  **Remote communication**
    *   Use SSE for scenarios requiring HTTP compatibility
    *   Consider security implications including authentication and authorization

### Message handling

1.  **Request processing**
    *   Validate inputs thoroughly
    *   Use type-safe schemas
    *   Handle errors gracefully
    *   Implement timeouts

2.  **Progress reporting**
    *   Use progress tokens for long operations
    *   Report progress incrementally
    *   Include total progress when known

3.  **Error management**
    *   Use appropriate error codes
    *   Include helpful error messages
    *   Clean up resources on errors

## Security considerations

1.  **Transport security**
    *   Use TLS for remote connections
    *   Validate connection origins
    *   Implement authentication when needed

2.  **Message validation**
    *   Validate all incoming messages
    *   Sanitize inputs
    *   Check message size limits
    *   Verify JSON-RPC format

3.  **Resource protection**
    *   Implement access controls
    *   Validate resource paths
    *   Monitor resource usage
    *   Rate limit requests

4.  **Error handling**
    *   Don't leak sensitive information
    *   Log security-relevant errors
    *   Implement proper cleanup
    *   Handle DoS scenarios

## Debugging and monitoring

1.  **Logging**
    *   Log protocol events
    *   Track message flow
    *   Monitor performance
    *   Record errors

2.  **Diagnostics**
    *   Implement health checks
    *   Monitor connection state
    *   Track resource usage
    *   Profile performance

3.  **Testing**
    *   Test different transports
    *   Verify error handling
    *   Check edge cases
    *   Load test servers

